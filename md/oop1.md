# オブジェクト指向言語に触れる

## はじめに

* 目的: オブジェクト指向言語を使う動機を持ってもらうこと。
* 想定する読者:
  - プログラミングはC言語を学校の授業でやった程度。
  - 変数、関数は覚えている。
  - if文、while文、for文は覚えている。
  - 構造体・ポインタは覚えていない。

この文章で説明する「オブジェクト指向言語」は
C++やJavaなどの古典的なクラスベースのオブジェクト指向言語です。
静的型付けには限定はしません。

筆者の知識ではオブジェクト指向とは何かを厳密に説明することはできませんので、ご了承ください。
もし間違いがあればご指摘よろしくお願いいたします。

## 変数と値とデータ型
わざわざ書かなくても良い気がしますが、念のため書いておきます。

- 変数: 箱。`int i;`の`i`のこと。
- 変数の型: 箱の種類。`int i;`の`int`のこと。
- データ: 箱の中身。`i = 1`の`1`のこと。
- データの型: 箱の中身の種類。`1`の型は`int`、`1.0`の型は`double`、`'a'`の型は`char`。

## 構造体
構造体とは、幾つかの異なる型のデータをまとめて1つのデータ型にしたものです。
C言語を習ってからオブジェクト指向言語に触れる場合、
この「構造体」という概念が非常に重要になるので復習しておきましょう。

### 構造体 = 階層構造を持つデータ型
構造体とは次のようにして宣言して使う **データ型** です。
``` c
struct Person {   // 構造体の名前
  char name[];    // 構成要素(メンバ)の型と名前
  int age;
  double height;
  double weight;
};
```

これは
* `Person`型というデータの種類を定義する
* `Person`型のデータは
`name`, `age`, `height`, `weight`
の４つの属性を持っている

ということを宣言しているのです。
データの階層構造を宣言していることが分かるでしょうか。
階層構造というのはつまりフォルダ分けのようなものです。

![Person](img/Person.png)

この時点ではまだ、変数は作成されていません。
「データの構造の宣言」≠「変数の宣言」だからです。
使うときは下のように変数を宣言してから使います。
``` c
struct Person p;      // Person 型のデータを格納する変数 p を用意
p.name = "田中太郎";  // p の name に "田中太郎" を格納
p.age = 21;
p.height = 171.65;
p.weight = 65.63;
```

細かい文法は重要ではないので覚えなくて問題ありません。
こういうものがあることを知って下さい。

大事なのは、`char`や`int`のような単純な概念を下位要素として、
`Person`という複雑な概念を定義したということです。

### なんで構造体なんてものがあるのか
なんで構造体なんてものがあるのか、
それは普段パソコンを使っていてフォルダを作るのと同じ理由です。
 **関連性の高いもの** を **名前を付けてまとめる** ことで全体を理解しやすくするためです。
管理している人が同じファイルや、必要になるタイミングが同じファイル、
同じアプリケーションから使うファイルを適切な名前のフォルダに入れておくと便利ですよね？

データがひとまとめになっていると特に便利なのは **データを持ち運ぶとき** です。
C言語において「データを持ち運ぶとき」とはどんな状況でしょうか？
それは関数に  引数を渡すときと、関数から戻り値を受け取るときです。

```c
// 3次元座標
struct Point3D {
  double x;
  double y;
  double z;
};

// 外積の計算
struct Point3D cross(struct Point3D a, struct Point3D b) {
  struct Point3D c;
  c.x = a.y * b.z - a.z * b.y;
  c.y = a.z * b.x - a.x * b.z;
  c.z = a.x * b.y - a.y * b.x;
  return p;
}


void main() {
  struct Point3D p1 = {1, 4, 3};      // p1 = (1, 4, 3)
  struct Point3D p2 = {5, 0, 6};      // p2 = (5, 0, 6)
  struct Point3D p3 = cross(p1, p2);  // p3 = p1 × p2
}
```

上の`cross`関数は、実質的には`double`型6つを引数として`double`型3つを返す関数ですが、
`Point3D`構造体を使っているおかげでだいぶ見通しが良くなっています。

### 構造体についてのまとめ
構造体とは、
「`Person`型のデータは`char[]`型の`name`を内部データとして持っている」といった、
データの階層構造を表現したものです。

`int`や`double`だけでなく構造体を積極的に使うことでデータの関連性が明示的になり、
また関数の引数や戻り値をシンプルにまとめることができます。

## モジュール
一般的に、ソフトウェアは何らかの状態を保持していて、
入力に応じてその状態を変化させながら処理を進めます。

![入出力](img/software.png)

プログラムが大きく複雑になり続けると、
内部状態や、それらを操作する関数もどんどん増えていきます。
そして、ごく自然な流れとしてそれらを分割しようと思うことになります。

![入出力](img/module.png)

こうして「モジュール」と呼ばれる単位でプログラムが分割されます。
C言語では1つ1つの .cファイル がモジュールです。

例えば下のような、ロボットアームを操作するためのモジュールを考えてみましょう。
```c
/* robot_arm.c */

// 重要: static なグローバル変数は他の .cファイル からアクセスできません。
static FILE* device_file;  // ロボットアームのデバイスファイル
static double velocity;  // ロボットアームを動かす速度

// 通信開始
void connect(char* file_name) {
  device_file = fopen(file_name, "w");
}

// 通信終了
void disconnect() {
  fclose(device_file);
  device_file = NULL;
}

// アームを動かす速度を設定
void set_velocity(double v) {
  velocity = v;
}

// 指定した位置に手先を動かす
void move_to(double x, double y, double y) {
  // 逆運動学でうんたらかんたらして device_file に書き込み
  // もちろん velocity の情報も使う
}
```
```c
/* main.c */

void main() {
  connect("/dev/my_robot_arm");
  set_velocity(100);
  move_to(300, 100, 0);
  disconnect();
}
```
ロボットアームに関係した機能だけがまとまっていてなかなか便利そうです。

## 状態と振る舞い

プログラムが肥大化してきたときはモジュール化することになるという話をしました。

でも考えてみてください。
複数のロボットアームを同時に操作しようとするのは先ほどのモジュールでは不可能です。
接続しているロボットアームを記憶している変数(`device_file`と`velocity`)が
モジュールに対して1つしかないからです。
別のロボットアームに接続しようとして`connect()`を呼ぶと、
その前に接続していたロボットアームの情報が失われてしまいます。

どうすれば複数のロボットアームを扱えるようになるでしょうか。
1つの解決策としては、以下のように内部状態を構造体にして毎回渡すというものがあります。
```c
/* robot_arm.c */

typedef struct {
  FILE* device_file;
  double velocity;
} Arm;

void connect(Arm* arm, char* file_name) {
  // ...
}

void disconnect(Arm* arm) {
  // ...
}

void set_velocity(Arm* arm, double v) {
  // ...
}

void move_to(Arm* arm, double x, double y, double y) {
    // ...
}
```
```c
void main() {
  Arm arm1;
  Arm arm2;

  connect(&arm1, "/dev/my_robot_arm1");
  connect(&arm2, "/dev/my_robot_arm2");

  set_velocity(&arm1, 100);
  set_velocity(&arm2, 200);

  move_to(&arm1, 300, 100, 0);
  move_to(&arm2, 100, 300, 0);

  disconnect(&arm1);
  disconnect(&arm2);
}
```

グローバル変数が無くなりました。
今までグローバル変数だった内部状態を`Arm`構造体にまとめて外側にくくりだしたからです。
これは、モジュールを複製できるようになったと考えることができるでしょう。

さあ、オブジェクト指向における「オブジェクト」の概念まであと少しです。

構造体というのは関連性の高い情報をまとめるためのものでした。
一方、構造体で表現された「状態」というのは
「状態を参照・操作する処理」と非常に強い関連性を持っています。
では、**その処理も構造体に持たせてしまえば良い** のではないでしょうか？

```c++
// こんなふうに
arm.connect("/dev/my_robot_arm");
arm.set_velocity(100);
arm.move_to(300, 100, 0);
arm.disconnect();
```

そう、この「状態」と「状態を参照・操作する処理」を一纏めにしたものが
オブジェクト指向において「オブジェクト」と呼ばれるものなのです。

## クラスとインスタンス
やっとオブジェクトとは何かを説明できたので、
次はオブジェクト指向関連の基本的な用語である「クラス」と「インスタンス」について説明します。

### クラス
乱暴に言ってしまうとオブジェクトとは構造体に関数を持たせたデータです。
ですからオブジェクトも構造体のように型を定義します。
この「オブジェクトの型」のことを「クラス」と呼びます。

下はC++で「クラス」を宣言する際のコードです。
```c++
class Arm {
private:
  FILE* device_file;
  double velocity;

public:
  void connect(char* file_name) {
    // ...
  }

  void disconnect() {
    // ...
  }

  void set_velocity(double v) {
    // ...
  }

  void move_to(double x, double y, double y) {
    // ...
  }
}
```

一番最初のモジュールのソースコードを
`class Arm {...}`の中に丸ごと入れたような形になっていますよね。
この意味で、クラスは「モジュール」を拡張したものだということができます。


### インスタンス
クラスというのはあくまでもデータの型ですから、
実際に使用する場合は基本的にそのクラスのオブジェクト（データ本体）を生成する必要があります。
この「○○クラスのオブジェクト」のことを「○○クラスのインスタンス」といいます。

インスタンスの生成は以下のようにして行います。
```c++
void main() {
  Arm arm = Arm();  // Armクラスのインスタンスを生成している
  arm.connect("/dev/my_robot_arm");
  arm.set_velocity(100);
  arm.move_to(300, 100, 0);
  arm.disconnect();
}
```

構造体のときとほとんど変わらないですよね？
変数だけでなく関数もドットの後ろに現れるようになっただけです。

なお、オブジェクトが持っている関数のことは「メソッド」と呼ぶことが多いです。
これは初期のオブジェクト指向言語に由来するそうです。
